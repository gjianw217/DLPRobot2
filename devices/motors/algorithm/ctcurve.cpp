#include <cmath>
#include <iostream>
#include <iomanip>

#include "ctcurve.h"
#include "../../../utils/cconverter.h"
//#define TORDERNUM 10
//#define DLP_MAX_FRAMES 200

CTCurve::CTCurve():ICurve()
{

}

CTCurve::~CTCurve()
{

}

/**
* @brief By a given amount of time adn angle,driver pulse is generated byt T shape algorithm
* @param
    1 time ms
    2 angle 0.001
    3 pwm    size or length greater than 40000
* @return  no sense
*/
int CTCurve::CreatePulseCurve(const uint32_t time,const double &angle,uint32_t *pwm)
{

    dlp_log(DLP_LOG_DEBUG,"CTCurve::CreatePulseCurve");
    int ret,sums,steps;
    uint32_t frames;
    uint16_t refPulse[TORDERNUM+1]={0};
   // uint32_t ppwm[DLP_MAX_FRAMES+1]={0};;
    uint32_t *ppwm=pwm;
    if(0==time)
    {
        sums=CreateRefPulses(refPulse);
        steps=Angle2Step(angle);
        frames=ComputeFrames(steps,sums,refPulse,ppwm);
    }
    else
    {
        frames=ComputeFrameswithTime(time,angle,ppwm);
    }
#ifdef DLP_DEBUG
    std::cout<<"[msg] show --------------"<<std::endl;
    for(int i=0;i<frames;i++)
    {
        std::cout<<"[msg] "<<ppwm[i]<<std::endl;
    }
    std::cout<<"[msg] end ................"<<std::endl;
#endif // DLP_DEBUG

	return 0;
}

/**
* @brief creating a reference pulse, while executing the pulse on the deceleration phase of the reference pulse
* @param save the reference pulse pointer
* @return save the pulse sum qunlity
*/
int CTCurve::CreateRefPulses(uint16_t *pulses)
{
    int i,sum=0;

    for(i=0;i<TORDERNUM+1;i++)
    {
        //pulses[i-1]=(m_attr.max_speed-m_attr.min_speed)*(2*i-1)/(2*TORDERNUM)+m_attr.min_speed;
        pulses[i]=(m_attr.g.max_speed-m_attr.g.min_speed)*(i)/(TORDERNUM)+m_attr.g.min_speed;
        sum+=pulses[i];
        //std::cout<<pulses[i]<<"--";

    }

    return  2*sum;  //sum pulses
}

/**
* @brief converting the specifieed angle to the corresponding pulses by the ptz division and gear
* @param the specifieed angle
* @return pulses
*/
uint32_t CTCurve::Angle2Step(const float &value)
{
    double angle=value;
    //double step_angle=SubdivisionMappingAngle[num2division(m_attr.division)];;
    STEPMOTORDIVISION division=ratio2division(m_attr.g.division);
    double step_angle=division2angle(division);

    uint32_t step = (uint32_t)(angle*m_attr.g.gear[1]/m_attr.g.gear[0]/step_angle);

#ifdef DLP_DEBUG
    std::cout<<"[msg] Request Angles "<< angle<<" to Steps "<<step<<std::endl;
    std::cout<<"[msg] gear[1] "<<m_attr.g.gear[1]<<" gear[0] "<<m_attr.g.gear[0]<<std::endl;
    std::cout<<"[msg] step angle "<<step_angle<<std::endl;
#endif // DLP_DEBUG

    return step ;

}
/**
* @brief generate the real driving pulse
* @param
    steps:      angle conversion into pulses
    ref_sum:    reference pulses
    ref_step*:  reference pulses array
    pulses*:    angle conversion pulses array
* @return frames
* @note
    frames format
    frames  data1 data2 ...
*/
int CTCurve::ComputeFrames(const uint32_t &steps,const uint16_t &ref_sum,const uint16_t *ref_step,uint32_t *pulses)
{
    assert(NULL!=ref_step);

    uint32_t ret,i,j,value;
    uint32_t frames=0;

    std::cout<<steps<<":"<<ref_sum<<":"<<std::endl;

    if (steps>ref_sum)
	{

		value=(steps-ref_sum); //constantSpeedNum

		frames=2*TORDERNUM+(steps-ref_sum)/m_attr.g.max_speed+1;
		std::cout<<"frames "<< frames<<std::endl;
        pulses[0]=frames;
		for(i=1;i<TORDERNUM+1;i++) //save the variable speed pulses
		{
            pulses[i]=ref_step[i-1];
            pulses[frames-i]=ref_step[i-1];
		}

		for(int i=TORDERNUM+1;i<frames-TORDERNUM;i++) //save the constant speed pulses
		{
            pulses[i]=m_attr.g.max_speed;

		}

		pulses[i]=(steps-ref_sum)%m_attr.g.max_speed;

	}
	else
	{
        std::cout<<"only accelaration"<<std::endl;
        uint16_t step_num=steps;
        for(i=0;i<TORDERNUM;i++)
		{
			if(step_num<2*ref_step[i])
			{
				frames=(i+1);
				break;
			}
			else
			{
                step_num=step_num-2*ref_step[i];

			}

        }

        std::cout<<"frames"<<frames<<std::endl;
        pulses[0]=2*frames;
		for(i=1;i<frames;i++)
		{
            pulses[i]=ref_step[i-1];
        }
		for(i=2*frames,j=0;i>frames+1;i--,j++)
		{
             pulses[i]=ref_step[j];
		}
		pulses[frames]=step_num/2;
		pulses[frames+1]=step_num/2;

	  }//else

    return frames;
	return 0;

}

/**
* @brief
* @param
* @return
*/
int CTCurve::ComputeFrameswithTime(uint32_t time,const float &angle,uint32_t *pulses)
{

    uint32_t frames= time/20;
    int32_t temp=frames-2*TORDERNUM;
    //If greater than zero, then there is uniform speed phase and to modify the speed by the solving equations
    if(temp>0)
    {
        uint16_t step_num=Angle2Step(angle);
        temp+=TORDERNUM*(TORDERNUM-1)/2;;
        uint32_t const_num=step_num-TORDERNUM*m_attr.g.min_speed;
        uint16_t speed= const_num/temp;

        uint16_t default_speed=GetMaxSpeed();
        //set the max speed
        SetMaxSpeed(speed);
        //set the time 0
        time=0;
        //assign
        CreatePulseCurve(time,angle,pulses);
        //restore the max speed
        SetMaxSpeed(default_speed);
    }
    else
    {


    }

	return 0;


}


/**
*@deprecated
*/
int CTCurve::CreatePulses()
{
	return 0;

}



